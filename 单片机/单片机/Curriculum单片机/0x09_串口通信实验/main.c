/**************************************************************************************
串口通信实验

波特率 : bits/s, 2400, 4800, 9600, 推荐 9600
		 96 - N - 8 - 1

实验现象：下载程序后，当串口助手发送数据给单片机，单片机原封不动转发给串口助手显示
注意事项：使用黄色跳线帽将CH340旁的P5端子的UTX和P30短接，URX和P31短接，出厂默认已短接好																				  
***************************************************************************************
// https://blog.csdn.net/qq_65980796/article/details/131996779 定时器/计数器工作模式
// https://blog.csdn.net/m0_56399733/article/details/133904885 中断介绍
// https://blog.csdn.net/m0_56399733/article/details/133989424 串行口通信
#include "reg52.h"

typedef unsigned int u16;	 
typedef unsigned char u8;

// 串口通信中断配置函数，通过设置TH和TL即可确定定时时间
// baud：波特率对应的TH、TL装载值
void uart_init(u8 baud) {
	/*
	在8051单片机中，串口通信是通过定时器来实现的。
	定时器的工作方式（Mode）决定了定时器的工作模式和计数方式。
	在串口通信中，我们需要使用定时器来生成波特率，以便与外部设备进行正确的通信。
	因此，我们需要将定时器配置为正确的工作方式，以生成正确的波特率。
	在示例代码中，我们将定时器1（TMOD）配置为方式2，这是一种8位自动重载模式。
	这种工作方式适用于串口通信，因为它可以根据定时器的溢出来生成正确的波特率。
	通过设定 TH1 和 TL1 的初值，我们可以实现所需的波特率，这里 TH1 和 TL1 的值用于设定波特率为9600。
	所以，更改 TMOD 的工作方式是为了配合串口通信的需求，确保定时器能够正确地生成所需的波特率，以实现正确的通信速率。
	*/ 
	
	/*
		定时器/计数器工作模式寄存器 TMOD
	*/
	TMOD |= 0X20;	//设置计数器工作方式2, M1 = 0, M0 = 0, 用于产生波特率
	
	/* 
		串口控制寄存器 SCON 
	    SM0 SM1 SM2 REN TB8 RB8 TI RI
		方式 1 : SM0 = 0, SM1 = 1, 10 步异位收发器（8位数据）
		SM2 : 设为 0
		REN = 1 : 数据接收使能位
		其余位默认为 0
	*/
	SCON=0X50;	//设置串口工作方式为 1
	
	/* 
		PCON 电源控制寄存器 
		最高位 SMOD : 设为 1 时波特率加倍
		这里选择波特率加倍
	*/
	PCON=0X80; 	
	
	TH1=baud;	//计数器初始值设置 (用串口助手计算) 
	TL1=baud; // 基于工作方式, TL1 用于重置 TH1 
	ES = 1;		//打开 SCON 寄存器接收中断
	EA = 1;		//打开总中断
	TR1 = 1;		//打开计数器		
}


void main()
{	
	uart_init(0XFA); //波特率为9600，由 51波特率计算.exe 计算

	while(1)
	{			
							
	}		
}

// RI 接受控制器
// TI 发送控制器
void uart() interrupt 4 //串口通信中断函数
{
	u8 rec_data;
	RI = 0;			// 清除接收中断标志位
	rec_data = SBUF; // 存储接收到的数据
	SBUF = rec_data; // 将接收到的数据放入到发送寄存器
	while(!TI);		 // 等待发送数据完成
	TI=0;			 // 清除发送完成标志位				
}
